\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{pathlib}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{Path}

\PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{torch}

\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{configs}\PYG{n+nn}{.}\PYG{n+nn}{types}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{FeatureType}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{datasets}\PYG{n+nn}{.}\PYG{n+nn}{lerobot\PYGZus{}dataset}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{LeRobotDataset}\PYG{p}{,} \PYG{n}{LeRobotDatasetMetadata}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{datasets}\PYG{n+nn}{.}\PYG{n+nn}{utils}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{dataset\PYGZus{}to\PYGZus{}policy\PYGZus{}features}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{policies}\PYG{n+nn}{.}\PYG{n+nn}{act}\PYG{n+nn}{.}\PYG{n+nn}{configuration\PYGZus{}act}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{ACTConfig}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{policies}\PYG{n+nn}{.}\PYG{n+nn}{act}\PYG{n+nn}{.}\PYG{n+nn}{modeling\PYGZus{}act}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{ACTPolicy}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{policies}\PYG{n+nn}{.}\PYG{n+nn}{factory}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{make\PYGZus{}pre\PYGZus{}post\PYGZus{}processors}


\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{make\PYGZus{}delta\PYGZus{}timestamps}\PYG{p}{(}\PYG{n}{delta\PYGZus{}indices}\PYG{p}{:} \PYG{n+nb}{list}\PYG{p}{[}\PYG{n+nb}{int}\PYG{p}{]} \PYG{o}{|} \PYG{k+kc}{None}\PYG{p}{,} \PYG{n}{fps}\PYG{p}{:} \PYG{n+nb}{int}\PYG{p}{)} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZgt{}} \PYG{n+nb}{list}\PYG{p}{[}\PYG{n+nb}{float}\PYG{p}{]}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{delta\PYGZus{}indices} \PYG{o+ow}{is} \PYG{k+kc}{None}\PYG{p}{:}
        \PYG{k}{return} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}

    \PYG{k}{return} \PYG{p}{[}\PYG{n}{i} \PYG{o}{/} \PYG{n}{fps} \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{delta\PYGZus{}indices}\PYG{p}{]}


\PYG{n}{output\PYGZus{}directory} \PYG{o}{=} \PYG{n}{Path}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{outputs/robot\PYGZus{}learning\PYGZus{}tutorial/act}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{output\PYGZus{}directory}\PYG{o}{.}\PYG{n}{mkdir}\PYG{p}{(}\PYG{n}{parents}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{exist\PYGZus{}ok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Select your device}
\PYG{n}{device} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} or \PYGZdq{}cuda\PYGZdq{} or \PYGZdq{}cpu\PYGZdq{}}

\PYG{n}{dataset\PYGZus{}id} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lerobot/svla\PYGZus{}so101\PYGZus{}pickplace}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} This specifies the inputs the model will be expecting and the outputs it will produce}
\PYG{n}{dataset\PYGZus{}metadata} \PYG{o}{=} \PYG{n}{LeRobotDatasetMetadata}\PYG{p}{(}\PYG{n}{dataset\PYGZus{}id}\PYG{p}{)}
\PYG{n}{features} \PYG{o}{=} \PYG{n}{dataset\PYGZus{}to\PYGZus{}policy\PYGZus{}features}\PYG{p}{(}\PYG{n}{dataset\PYGZus{}metadata}\PYG{o}{.}\PYG{n}{features}\PYG{p}{)}

\PYG{n}{output\PYGZus{}features} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n}{key}\PYG{p}{:} \PYG{n}{ft} \PYG{k}{for} \PYG{n}{key}\PYG{p}{,} \PYG{n}{ft} \PYG{o+ow}{in} \PYG{n}{features}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)} \PYG{k}{if} \PYG{n}{ft}\PYG{o}{.}\PYG{n}{type} \PYG{o+ow}{is} \PYG{n}{FeatureType}\PYG{o}{.}\PYG{n}{ACTION}\PYG{p}{\PYGZcb{}}
\PYG{n}{input\PYGZus{}features} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n}{key}\PYG{p}{:} \PYG{n}{ft} \PYG{k}{for} \PYG{n}{key}\PYG{p}{,} \PYG{n}{ft} \PYG{o+ow}{in} \PYG{n}{features}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)} \PYG{k}{if} \PYG{n}{key} \PYG{o+ow}{not} \PYG{o+ow}{in} \PYG{n}{output\PYGZus{}features}\PYG{p}{\PYGZcb{}}

\PYG{n}{cfg} \PYG{o}{=} \PYG{n}{ACTConfig}\PYG{p}{(}\PYG{n}{input\PYGZus{}features}\PYG{o}{=}\PYG{n}{input\PYGZus{}features}\PYG{p}{,} \PYG{n}{output\PYGZus{}features}\PYG{o}{=}\PYG{n}{output\PYGZus{}features}\PYG{p}{)}
\PYG{n}{policy} \PYG{o}{=} \PYG{n}{ACTPolicy}\PYG{p}{(}\PYG{n}{cfg}\PYG{p}{)}
\PYG{n}{preprocessor}\PYG{p}{,} \PYG{n}{postprocessor} \PYG{o}{=} \PYG{n}{make\PYGZus{}pre\PYGZus{}post\PYGZus{}processors}\PYG{p}{(}\PYG{n}{cfg}\PYG{p}{,} \PYG{n}{dataset\PYGZus{}stats}\PYG{o}{=}\PYG{n}{dataset\PYGZus{}metadata}\PYG{o}{.}\PYG{n}{stats}\PYG{p}{)}

\PYG{n}{policy}\PYG{o}{.}\PYG{n}{train}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{policy}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{device}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} To perform action chunking, ACT expects a given number of actions as targets}
\PYG{n}{delta\PYGZus{}timestamps} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{action}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{make\PYGZus{}delta\PYGZus{}timestamps}\PYG{p}{(}\PYG{n}{cfg}\PYG{o}{.}\PYG{n}{action\PYGZus{}delta\PYGZus{}indices}\PYG{p}{,} \PYG{n}{dataset\PYGZus{}metadata}\PYG{o}{.}\PYG{n}{fps}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} add image features if they are present}
\PYG{n}{delta\PYGZus{}timestamps} \PYG{o}{|}\PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{n}{k}\PYG{p}{:} \PYG{n}{make\PYGZus{}delta\PYGZus{}timestamps}\PYG{p}{(}\PYG{n}{cfg}\PYG{o}{.}\PYG{n}{observation\PYGZus{}delta\PYGZus{}indices}\PYG{p}{,} \PYG{n}{dataset\PYGZus{}metadata}\PYG{o}{.}\PYG{n}{fps}\PYG{p}{)} \PYG{k}{for} \PYG{n}{k} \PYG{o+ow}{in} \PYG{n}{cfg}\PYG{o}{.}\PYG{n}{image\PYGZus{}features}
\PYG{p}{\PYGZcb{}}

\PYG{c+c1}{\PYGZsh{} Instantiate the dataset}
\PYG{n}{dataset} \PYG{o}{=} \PYG{n}{LeRobotDataset}\PYG{p}{(}\PYG{n}{dataset\PYGZus{}id}\PYG{p}{,} \PYG{n}{delta\PYGZus{}timestamps}\PYG{o}{=}\PYG{n}{delta\PYGZus{}timestamps}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create the optimizer and dataloader for offline training}
\PYG{n}{optimizer} \PYG{o}{=} \PYG{n}{cfg}\PYG{o}{.}\PYG{n}{get\PYGZus{}optimizer\PYGZus{}preset}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{build}\PYG{p}{(}\PYG{n}{policy}\PYG{o}{.}\PYG{n}{parameters}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{batch\PYGZus{}size} \PYG{o}{=} \PYG{l+m+mi}{32}
\PYG{n}{dataloader} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{utils}\PYG{o}{.}\PYG{n}{data}\PYG{o}{.}\PYG{n}{DataLoader}\PYG{p}{(}
    \PYG{n}{dataset}\PYG{p}{,}
    \PYG{n}{batch\PYGZus{}size}\PYG{o}{=}\PYG{n}{batch\PYGZus{}size}\PYG{p}{,}
    \PYG{n}{shuffle}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
    \PYG{n}{pin\PYGZus{}memory}\PYG{o}{=}\PYG{n}{device}\PYG{o}{.}\PYG{n}{type} \PYG{o}{!=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cpu}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}
    \PYG{n}{drop\PYGZus{}last}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}
\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Number of training steps and logging frequency}
\PYG{n}{training\PYGZus{}steps} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{n}{log\PYGZus{}freq} \PYG{o}{=} \PYG{l+m+mi}{1}

\PYG{c+c1}{\PYGZsh{} Run training loop}
\PYG{n}{step} \PYG{o}{=} \PYG{l+m+mi}{0}
\PYG{n}{done} \PYG{o}{=} \PYG{k+kc}{False}
\PYG{k}{while} \PYG{o+ow}{not} \PYG{n}{done}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{batch} \PYG{o+ow}{in} \PYG{n}{dataloader}\PYG{p}{:}
        \PYG{n}{batch} \PYG{o}{=} \PYG{n}{preprocessor}\PYG{p}{(}\PYG{n}{batch}\PYG{p}{)}
        \PYG{n}{loss}\PYG{p}{,} \PYG{n}{\PYGZus{}} \PYG{o}{=} \PYG{n}{policy}\PYG{o}{.}\PYG{n}{forward}\PYG{p}{(}\PYG{n}{batch}\PYG{p}{)}
        \PYG{n}{loss}\PYG{o}{.}\PYG{n}{backward}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{step}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{optimizer}\PYG{o}{.}\PYG{n}{zero\PYGZus{}grad}\PYG{p}{(}\PYG{p}{)}

        \PYG{k}{if} \PYG{n}{step} \PYG{o}{\PYGZpc{}} \PYG{n}{log\PYGZus{}freq} \PYG{o}{==} \PYG{l+m+mi}{0}\PYG{p}{:}
            \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{step: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{step}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ loss: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{loss}\PYG{o}{.}\PYG{n}{item}\PYG{p}{(}\PYG{p}{)}\PYG{l+s+si}{:}\PYG{l+s+s2}{.3f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
        \PYG{n}{step} \PYG{o}{+}\PYG{o}{=} \PYG{l+m+mi}{1}
        \PYG{k}{if} \PYG{n}{step} \PYG{o}{\PYGZgt{}}\PYG{o}{=} \PYG{n}{training\PYGZus{}steps}\PYG{p}{:}
            \PYG{n}{done} \PYG{o}{=} \PYG{k+kc}{True}
            \PYG{k}{break}

\PYG{c+c1}{\PYGZsh{} Save the policy checkpoint, alongside the pre/post processors}
\PYG{n}{policy}\PYG{o}{.}\PYG{n}{save\PYGZus{}pretrained}\PYG{p}{(}\PYG{n}{output\PYGZus{}directory}\PYG{p}{)}
\PYG{n}{preprocessor}\PYG{o}{.}\PYG{n}{save\PYGZus{}pretrained}\PYG{p}{(}\PYG{n}{output\PYGZus{}directory}\PYG{p}{)}
\PYG{n}{postprocessor}\PYG{o}{.}\PYG{n}{save\PYGZus{}pretrained}\PYG{p}{(}\PYG{n}{output\PYGZus{}directory}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Save all assets to the Hub}
\PYG{n}{policy}\PYG{o}{.}\PYG{n}{push\PYGZus{}to\PYGZus{}hub}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fracapuano/robot\PYGZus{}learning\PYGZus{}tutorial\PYGZus{}act\PYGZus{}example\PYGZus{}model}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{preprocessor}\PYG{o}{.}\PYG{n}{push\PYGZus{}to\PYGZus{}hub}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fracapuano/robot\PYGZus{}learning\PYGZus{}tutorial\PYGZus{}act\PYGZus{}example\PYGZus{}pipeline}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{postprocessor}\PYG{o}{.}\PYG{n}{push\PYGZus{}to\PYGZus{}hub}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{fracapuano/robot\PYGZus{}learning\PYGZus{}tutorial\PYGZus{}act\PYGZus{}example\PYGZus{}pipeline}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{MintedVerbatim}
