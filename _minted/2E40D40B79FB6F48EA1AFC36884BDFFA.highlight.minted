\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{multiprocessing}\PYG{+w}{ }\PYG{k}{as}\PYG{+w}{ }\PYG{n+nn}{mp}
\PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{signal}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{typing}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{Callable}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{pathlib}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{Path}

\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{datasets}\PYG{n+nn}{.}\PYG{n+nn}{lerobot\PYGZus{}dataset}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{LeRobotDataset}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{datasets}\PYG{n+nn}{.}\PYG{n+nn}{utils}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{hw\PYGZus{}to\PYGZus{}dataset\PYGZus{}features}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{envs}\PYG{n+nn}{.}\PYG{n+nn}{configs}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{HILSerlProcessorConfig}\PYG{p}{,} \PYG{n}{HILSerlRobotEnvConfig}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{policies}\PYG{n+nn}{.}\PYG{n+nn}{sac}\PYG{n+nn}{.}\PYG{n+nn}{configuration\PYGZus{}sac}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{SACConfig}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{policies}\PYG{n+nn}{.}\PYG{n+nn}{sac}\PYG{n+nn}{.}\PYG{n+nn}{modeling\PYGZus{}sac}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{SACPolicy}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{policies}\PYG{n+nn}{.}\PYG{n+nn}{sac}\PYG{n+nn}{.}\PYG{n+nn}{reward\PYGZus{}model}\PYG{n+nn}{.}\PYG{n+nn}{modeling\PYGZus{}classifier}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{Classifier}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{rl}\PYG{n+nn}{.}\PYG{n+nn}{buffer}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{ReplayBuffer}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{rl}\PYG{n+nn}{.}\PYG{n+nn}{gym\PYGZus{}manipulator}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{make\PYGZus{}robot\PYGZus{}env}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{robots}\PYG{n+nn}{.}\PYG{n+nn}{so100\PYGZus{}follower}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{SO100FollowerConfig}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{teleoperators}\PYG{n+nn}{.}\PYG{n+nn}{so100\PYGZus{}leader}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{SO100LeaderConfig}


\PYG{n}{run\PYGZus{}learner}\PYG{p}{:} \PYG{n}{Callable} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}  \PYG{c+c1}{\PYGZsh{} use/modify the functions defined earlier}
\PYG{n}{run\PYGZus{}actor}\PYG{p}{:} \PYG{n}{Callable} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

\PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}Main function \PYGZhy{} coordinates actor and learner processes.\PYGZdq{}\PYGZdq{}\PYGZdq{}}

\PYG{n}{device} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mps}\PYG{l+s+s2}{\PYGZdq{}}  \PYG{c+c1}{\PYGZsh{} or \PYGZdq{}cuda\PYGZdq{} or \PYGZdq{}cpu\PYGZdq{}}
\PYG{n}{output\PYGZus{}directory} \PYG{o}{=} \PYG{n}{Path}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{outputs/robot\PYGZus{}learning\PYGZus{}tutorial/hil\PYGZus{}serl}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{output\PYGZus{}directory}\PYG{o}{.}\PYG{n}{mkdir}\PYG{p}{(}\PYG{n}{parents}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,} \PYG{n}{exist\PYGZus{}ok}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} find ports using lerobot\PYGZhy{}find\PYGZhy{}port}
\PYG{n}{follower\PYGZus{}port} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{leader\PYGZus{}port} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

\PYG{c+c1}{\PYGZsh{} the robot ids are used the load the right calibration files}
\PYG{n}{follower\PYGZus{}id} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}
\PYG{n}{leader\PYGZus{}id} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}

\PYG{c+c1}{\PYGZsh{} A pretrained model (to be used in\PYGZhy{}distribution!)}
\PYG{n}{reward\PYGZus{}classifier\PYGZus{}id} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lerobot/reward\PYGZus{}classifier\PYGZus{}hil\PYGZus{}serl\PYGZus{}example}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{reward\PYGZus{}classifier} \PYG{o}{=} \PYG{n}{Classifier}\PYG{o}{.}\PYG{n}{from\PYGZus{}pretrained}\PYG{p}{(}\PYG{n}{reward\PYGZus{}classifier\PYGZus{}id}\PYG{p}{)}

\PYG{n}{reward\PYGZus{}classifier}\PYG{o}{.}\PYG{n}{to}\PYG{p}{(}\PYG{n}{device}\PYG{p}{)}
\PYG{n}{reward\PYGZus{}classifier}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{MAX\PYGZus{}EPISODES} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{MAX\PYGZus{}STEPS\PYGZus{}PER\PYGZus{}EPISODE} \PYG{o}{=} \PYG{l+m+mi}{20}

\PYG{c+c1}{\PYGZsh{} Robot and environment configuration}
\PYG{n}{robot\PYGZus{}cfg} \PYG{o}{=} \PYG{n}{SO100FollowerConfig}\PYG{p}{(}\PYG{n}{port}\PYG{o}{=}\PYG{n}{follower\PYGZus{}port}\PYG{p}{,} \PYG{n+nb}{id}\PYG{o}{=}\PYG{n}{follower\PYGZus{}id}\PYG{p}{)}
\PYG{n}{teleop\PYGZus{}cfg} \PYG{o}{=} \PYG{n}{SO100LeaderConfig}\PYG{p}{(}\PYG{n}{port}\PYG{o}{=}\PYG{n}{leader\PYGZus{}port}\PYG{p}{,} \PYG{n+nb}{id}\PYG{o}{=}\PYG{n}{leader\PYGZus{}id}\PYG{p}{)}
\PYG{n}{processor\PYGZus{}cfg} \PYG{o}{=} \PYG{n}{HILSerlProcessorConfig}\PYG{p}{(}\PYG{n}{control\PYGZus{}mode}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{leader}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{env\PYGZus{}cfg} \PYG{o}{=} \PYG{n}{HILSerlRobotEnvConfig}\PYG{p}{(}\PYG{n}{robot}\PYG{o}{=}\PYG{n}{robot\PYGZus{}cfg}\PYG{p}{,} \PYG{n}{teleop}\PYG{o}{=}\PYG{n}{teleop\PYGZus{}cfg}\PYG{p}{,} \PYG{n}{processor}\PYG{o}{=}\PYG{n}{processor\PYGZus{}cfg}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create robot environment}
\PYG{n}{env}\PYG{p}{,} \PYG{n}{teleop\PYGZus{}device} \PYG{o}{=} \PYG{n}{make\PYGZus{}robot\PYGZus{}env}\PYG{p}{(}\PYG{n}{env\PYGZus{}cfg}\PYG{p}{)}

\PYG{n}{obs\PYGZus{}features} \PYG{o}{=} \PYG{n}{hw\PYGZus{}to\PYGZus{}dataset\PYGZus{}features}\PYG{p}{(}\PYG{n}{env}\PYG{o}{.}\PYG{n}{robot}\PYG{o}{.}\PYG{n}{observation\PYGZus{}features}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{observation}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{action\PYGZus{}features} \PYG{o}{=} \PYG{n}{hw\PYGZus{}to\PYGZus{}dataset\PYGZus{}features}\PYG{p}{(}\PYG{n}{env}\PYG{o}{.}\PYG{n}{robot}\PYG{o}{.}\PYG{n}{action\PYGZus{}features}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{action}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create SAC policy for action selection}
\PYG{n}{policy\PYGZus{}cfg} \PYG{o}{=} \PYG{n}{SACConfig}\PYG{p}{(}
    \PYG{n}{device}\PYG{o}{=}\PYG{n}{device}\PYG{p}{,}
    \PYG{n}{input\PYGZus{}features}\PYG{o}{=}\PYG{n}{obs\PYGZus{}features}\PYG{p}{,}
    \PYG{n}{output\PYGZus{}features}\PYG{o}{=}\PYG{n}{action\PYGZus{}features}\PYG{p}{,}
\PYG{p}{)}

\PYG{n}{policy\PYGZus{}actor} \PYG{o}{=} \PYG{n}{SACPolicy}\PYG{p}{(}\PYG{n}{policy\PYGZus{}cfg}\PYG{p}{)}
\PYG{n}{policy\PYGZus{}learner} \PYG{o}{=} \PYG{n}{SACPolicy}\PYG{p}{(}\PYG{n}{policy\PYGZus{}cfg}\PYG{p}{)}

\PYG{n}{demonstrations\PYGZus{}repo\PYGZus{}id} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lerobot/example\PYGZus{}hil\PYGZus{}serl\PYGZus{}dataset}\PYG{l+s+s2}{\PYGZdq{}}
\PYG{n}{offline\PYGZus{}dataset} \PYG{o}{=} \PYG{n}{LeRobotDataset}\PYG{p}{(}\PYG{n}{repo\PYGZus{}id}\PYG{o}{=}\PYG{n}{demonstrations\PYGZus{}repo\PYGZus{}id}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Online buffer: initialized from scratch}
\PYG{n}{online\PYGZus{}replay\PYGZus{}buffer} \PYG{o}{=} \PYG{n}{ReplayBuffer}\PYG{p}{(}\PYG{n}{device}\PYG{o}{=}\PYG{n}{device}\PYG{p}{,} \PYG{n}{state\PYGZus{}keys}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{obs\PYGZus{}features}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Offline buffer: Created from dataset (pre\PYGZhy{}populated it with demonstrations)}
\PYG{n}{offline\PYGZus{}replay\PYGZus{}buffer} \PYG{o}{=} \PYG{n}{ReplayBuffer}\PYG{o}{.}\PYG{n}{from\PYGZus{}lerobot\PYGZus{}dataset}\PYG{p}{(}
    \PYG{n}{lerobot\PYGZus{}dataset}\PYG{o}{=}\PYG{n}{offline\PYGZus{}dataset}\PYG{p}{,} \PYG{n}{device}\PYG{o}{=}\PYG{n}{device}\PYG{p}{,} \PYG{n}{state\PYGZus{}keys}\PYG{o}{=}\PYG{n+nb}{list}\PYG{p}{(}\PYG{n}{obs\PYGZus{}features}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}\PYG{p}{)}
\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create communication channels between learner and actor processes}
\PYG{n}{transitions\PYGZus{}queue} \PYG{o}{=} \PYG{n}{mp}\PYG{o}{.}\PYG{n}{Queue}\PYG{p}{(}\PYG{n}{maxsize}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}
\PYG{n}{parameters\PYGZus{}queue} \PYG{o}{=} \PYG{n}{mp}\PYG{o}{.}\PYG{n}{Queue}\PYG{p}{(}\PYG{n}{maxsize}\PYG{o}{=}\PYG{l+m+mi}{2}\PYG{p}{)}
\PYG{n}{shutdown\PYGZus{}event} \PYG{o}{=} \PYG{n}{mp}\PYG{o}{.}\PYG{n}{Event}\PYG{p}{(}\PYG{p}{)}


\PYG{c+c1}{\PYGZsh{} Signal handler for graceful shutdown}
\PYG{k}{def}\PYG{+w}{ }\PYG{n+nf}{signal\PYGZus{}handler}\PYG{p}{(}\PYG{n}{sig}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s2}{Signal }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{sig}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s2}{ received, shutting down...}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{shutdown\PYGZus{}event}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{p}{)}


\PYG{n}{signal}\PYG{o}{.}\PYG{n}{signal}\PYG{p}{(}\PYG{n}{signal}\PYG{o}{.}\PYG{n}{SIGINT}\PYG{p}{,} \PYG{n}{signal\PYGZus{}handler}\PYG{p}{)}
\PYG{n}{signal}\PYG{o}{.}\PYG{n}{signal}\PYG{p}{(}\PYG{n}{signal}\PYG{o}{.}\PYG{n}{SIGTERM}\PYG{p}{,} \PYG{n}{signal\PYGZus{}handler}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} Create processes}
\PYG{n}{learner\PYGZus{}process} \PYG{o}{=} \PYG{n}{mp}\PYG{o}{.}\PYG{n}{Process}\PYG{p}{(}
    \PYG{n}{target}\PYG{o}{=}\PYG{n}{run\PYGZus{}learner}\PYG{p}{,}
    \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}
        \PYG{n}{transitions\PYGZus{}queue}\PYG{p}{,}
        \PYG{n}{parameters\PYGZus{}queue}\PYG{p}{,}
        \PYG{n}{shutdown\PYGZus{}event}\PYG{p}{,}
        \PYG{n}{policy\PYGZus{}learner}\PYG{p}{,}
        \PYG{n}{online\PYGZus{}replay\PYGZus{}buffer}\PYG{p}{,}
        \PYG{n}{offline\PYGZus{}replay\PYGZus{}buffer}\PYG{p}{,}
    \PYG{p}{)}\PYG{p}{,}
    \PYG{n}{kwargs}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{device}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{device}\PYG{p}{\PYGZcb{}}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} can run on accelerated hardware for training}
\PYG{p}{)}

\PYG{n}{actor\PYGZus{}process} \PYG{o}{=} \PYG{n}{mp}\PYG{o}{.}\PYG{n}{Process}\PYG{p}{(}
    \PYG{n}{target}\PYG{o}{=}\PYG{n}{run\PYGZus{}actor}\PYG{p}{,}
    \PYG{n}{args}\PYG{o}{=}\PYG{p}{(}
        \PYG{n}{transitions\PYGZus{}queue}\PYG{p}{,}
        \PYG{n}{parameters\PYGZus{}queue}\PYG{p}{,}
        \PYG{n}{shutdown\PYGZus{}event}\PYG{p}{,}
        \PYG{n}{policy\PYGZus{}actor}\PYG{p}{,}
        \PYG{n}{reward\PYGZus{}classifier}\PYG{p}{,}
        \PYG{n}{env\PYGZus{}cfg}\PYG{p}{,}
        \PYG{n}{output\PYGZus{}directory}\PYG{p}{,}
    \PYG{p}{)}\PYG{p}{,}
    \PYG{n}{kwargs}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{device}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{cpu}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}  \PYG{c+c1}{\PYGZsh{} actor is frozen, can run on CPU or accelerate for inference}
\PYG{p}{)}

\PYG{n}{learner\PYGZus{}process}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{actor\PYGZus{}process}\PYG{o}{.}\PYG{n}{start}\PYG{p}{(}\PYG{p}{)}

\PYG{k}{try}\PYG{p}{:}
    \PYG{c+c1}{\PYGZsh{} Wait for actor to finish (it controls the episode loop)}
    \PYG{n}{actor\PYGZus{}process}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{shutdown\PYGZus{}event}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{learner\PYGZus{}process}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{k}{except} \PYG{n+ne}{KeyboardInterrupt}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Main process interrupted}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
    \PYG{n}{shutdown\PYGZus{}event}\PYG{o}{.}\PYG{n}{set}\PYG{p}{(}\PYG{p}{)}
    \PYG{n}{actor\PYGZus{}process}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}
    \PYG{n}{learner\PYGZus{}process}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}\PYG{n}{timeout}\PYG{o}{=}\PYG{l+m+mi}{10}\PYG{p}{)}

\PYG{k}{finally}\PYG{p}{:}
    \PYG{k}{if} \PYG{n}{learner\PYGZus{}process}\PYG{o}{.}\PYG{n}{is\PYGZus{}alive}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{learner\PYGZus{}process}\PYG{o}{.}\PYG{n}{terminate}\PYG{p}{(}\PYG{p}{)}
    \PYG{k}{if} \PYG{n}{actor\PYGZus{}process}\PYG{o}{.}\PYG{n}{is\PYGZus{}alive}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{actor\PYGZus{}process}\PYG{o}{.}\PYG{n}{terminate}\PYG{p}{(}\PYG{p}{)}
\end{MintedVerbatim}
