\begin{MintedVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import}\PYG{+w}{ }\PYG{n+nn}{torch}

\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{cameras}\PYG{n+nn}{.}\PYG{n+nn}{opencv}\PYG{n+nn}{.}\PYG{n+nn}{configuration\PYGZus{}opencv}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{OpenCVCameraConfig}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{datasets}\PYG{n+nn}{.}\PYG{n+nn}{utils}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{hw\PYGZus{}to\PYGZus{}dataset\PYGZus{}features}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{policies}\PYG{n+nn}{.}\PYG{n+nn}{factory}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{make\PYGZus{}pre\PYGZus{}post\PYGZus{}processors}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{policies}\PYG{n+nn}{.}\PYG{n+nn}{smolvla}\PYG{n+nn}{.}\PYG{n+nn}{modeling\PYGZus{}smolvla}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{SmolVLAPolicy}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{policies}\PYG{n+nn}{.}\PYG{n+nn}{utils}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{build\PYGZus{}inference\PYGZus{}frame}\PYG{p}{,} \PYG{n}{make\PYGZus{}robot\PYGZus{}action}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{robots}\PYG{n+nn}{.}\PYG{n+nn}{so100\PYGZus{}follower}\PYG{n+nn}{.}\PYG{n+nn}{config\PYGZus{}so100\PYGZus{}follower}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{SO100FollowerConfig}
\PYG{k+kn}{from}\PYG{+w}{ }\PYG{n+nn}{lerobot}\PYG{n+nn}{.}\PYG{n+nn}{robots}\PYG{n+nn}{.}\PYG{n+nn}{so100\PYGZus{}follower}\PYG{n+nn}{.}\PYG{n+nn}{so100\PYGZus{}follower}\PYG{+w}{ }\PYG{k+kn}{import} \PYG{n}{SO100Follower}

\PYG{n}{MAX\PYGZus{}EPISODES} \PYG{o}{=} \PYG{l+m+mi}{5}
\PYG{n}{MAX\PYGZus{}STEPS\PYGZus{}PER\PYGZus{}EPISODE} \PYG{o}{=} \PYG{l+m+mi}{20}

\PYG{n}{device} \PYG{o}{=} \PYG{n}{torch}\PYG{o}{.}\PYG{n}{device}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} or \PYGZdq{}cuda\PYGZdq{} or \PYGZdq{}cpu\PYGZdq{}}
\PYG{n}{model\PYGZus{}id} \PYG{o}{=} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{lerobot/smolvla\PYGZus{}base}\PYG{l+s+s2}{\PYGZdq{}}

\PYG{n}{model} \PYG{o}{=} \PYG{n}{SmolVLAPolicy}\PYG{o}{.}\PYG{n}{from\PYGZus{}pretrained}\PYG{p}{(}\PYG{n}{model\PYGZus{}id}\PYG{p}{)}

\PYG{n}{preprocess}\PYG{p}{,} \PYG{n}{postprocess} \PYG{o}{=} \PYG{n}{make\PYGZus{}pre\PYGZus{}post\PYGZus{}processors}\PYG{p}{(}
    \PYG{n}{model}\PYG{o}{.}\PYG{n}{config}\PYG{p}{,}
    \PYG{n}{model\PYGZus{}id}\PYG{p}{,}
    \PYG{c+c1}{\PYGZsh{} This overrides allows to run on MPS, otherwise defaults to CUDA (if available)}
    \PYG{n}{preprocessor\PYGZus{}overrides}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{device\PYGZus{}processor}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{p}{\PYGZob{}}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{device}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{mps}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{\PYGZcb{}}\PYG{p}{\PYGZcb{}}\PYG{p}{,}
\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{} find ports using lerobot\PYGZhy{}find\PYGZhy{}port}
\PYG{n}{follower\PYGZus{}port} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}  \PYG{c+c1}{\PYGZsh{} something like \PYGZdq{}/dev/tty.usbmodem58760431631\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} the robot ids are used the load the right calibration files}
\PYG{n}{follower\PYGZus{}id} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}  \PYG{c+c1}{\PYGZsh{} something like \PYGZdq{}follower\PYGZus{}so100\PYGZdq{}}

\PYG{c+c1}{\PYGZsh{} Robot and environment configuration}
\PYG{c+c1}{\PYGZsh{} Camera keys must match the name and resolutions of the ones used for training!}
\PYG{c+c1}{\PYGZsh{} You can check the camera keys expected by a model in the info.json card on the model card on the Hub}
\PYG{n}{camera\PYGZus{}config} \PYG{o}{=} \PYG{p}{\PYGZob{}}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{camera1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{OpenCVCameraConfig}\PYG{p}{(}\PYG{n}{index\PYGZus{}or\PYGZus{}path}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{l+m+mi}{640}\PYG{p}{,} \PYG{n}{height}\PYG{o}{=}\PYG{l+m+mi}{480}\PYG{p}{,} \PYG{n}{fps}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{,}
    \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{camera2}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{:} \PYG{n}{OpenCVCameraConfig}\PYG{p}{(}\PYG{n}{index\PYGZus{}or\PYGZus{}path}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{n}{width}\PYG{o}{=}\PYG{l+m+mi}{640}\PYG{p}{,} \PYG{n}{height}\PYG{o}{=}\PYG{l+m+mi}{480}\PYG{p}{,} \PYG{n}{fps}\PYG{o}{=}\PYG{l+m+mi}{30}\PYG{p}{)}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}

\PYG{n}{robot\PYGZus{}cfg} \PYG{o}{=} \PYG{n}{SO100FollowerConfig}\PYG{p}{(}\PYG{n}{port}\PYG{o}{=}\PYG{n}{follower\PYGZus{}port}\PYG{p}{,} \PYG{n+nb}{id}\PYG{o}{=}\PYG{n}{follower\PYGZus{}id}\PYG{p}{,} \PYG{n}{cameras}\PYG{o}{=}\PYG{n}{camera\PYGZus{}config}\PYG{p}{)}
\PYG{n}{robot} \PYG{o}{=} \PYG{n}{SO100Follower}\PYG{p}{(}\PYG{n}{robot\PYGZus{}cfg}\PYG{p}{)}
\PYG{n}{robot}\PYG{o}{.}\PYG{n}{connect}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{task} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}  \PYG{c+c1}{\PYGZsh{} something like \PYGZdq{}pick the red block\PYGZdq{}}
\PYG{n}{robot\PYGZus{}type} \PYG{o}{=} \PYG{o}{.}\PYG{o}{.}\PYG{o}{.}  \PYG{c+c1}{\PYGZsh{} something like \PYGZdq{}so100\PYGZus{}follower\PYGZdq{} for multi\PYGZhy{}embodiment datasets}

\PYG{c+c1}{\PYGZsh{} This is used to match the raw observation keys to the keys expected by the policy}
\PYG{n}{action\PYGZus{}features} \PYG{o}{=} \PYG{n}{hw\PYGZus{}to\PYGZus{}dataset\PYGZus{}features}\PYG{p}{(}\PYG{n}{robot}\PYG{o}{.}\PYG{n}{action\PYGZus{}features}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{action}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{obs\PYGZus{}features} \PYG{o}{=} \PYG{n}{hw\PYGZus{}to\PYGZus{}dataset\PYGZus{}features}\PYG{p}{(}\PYG{n}{robot}\PYG{o}{.}\PYG{n}{observation\PYGZus{}features}\PYG{p}{,} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{observation}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{dataset\PYGZus{}features} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{o}{*}\PYG{o}{*}\PYG{n}{action\PYGZus{}features}\PYG{p}{,} \PYG{o}{*}\PYG{o}{*}\PYG{n}{obs\PYGZus{}features}\PYG{p}{\PYGZcb{}}

\PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{MAX\PYGZus{}EPISODES}\PYG{p}{)}\PYG{p}{:}
    \PYG{k}{for} \PYG{n}{\PYGZus{}} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{MAX\PYGZus{}STEPS\PYGZus{}PER\PYGZus{}EPISODE}\PYG{p}{)}\PYG{p}{:}
        \PYG{n}{obs} \PYG{o}{=} \PYG{n}{robot}\PYG{o}{.}\PYG{n}{get\PYGZus{}observation}\PYG{p}{(}\PYG{p}{)}
        \PYG{n}{obs\PYGZus{}frame} \PYG{o}{=} \PYG{n}{build\PYGZus{}inference\PYGZus{}frame}\PYG{p}{(}\PYG{n}{obs}\PYG{p}{,} \PYG{n}{dataset\PYGZus{}features}\PYG{p}{,} \PYG{n}{device}\PYG{p}{,} \PYG{n}{task}\PYG{o}{=}\PYG{n}{task}\PYG{p}{,} \PYG{n}{robot\PYGZus{}type}\PYG{o}{=}\PYG{n}{robot\PYGZus{}type}\PYG{p}{)}

        \PYG{n}{obs} \PYG{o}{=} \PYG{n}{preprocess}\PYG{p}{(}\PYG{n}{obs\PYGZus{}frame}\PYG{p}{)}

        \PYG{n}{action} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{select\PYGZus{}action}\PYG{p}{(}\PYG{n}{obs}\PYG{p}{)}
        \PYG{n}{action} \PYG{o}{=} \PYG{n}{postprocess}\PYG{p}{(}\PYG{n}{action}\PYG{p}{)}
        \PYG{n}{action} \PYG{o}{=} \PYG{n}{make\PYGZus{}robot\PYGZus{}action}\PYG{p}{(}\PYG{n}{action}\PYG{p}{,} \PYG{n}{dataset\PYGZus{}features}\PYG{p}{)}
        \PYG{n}{robot}\PYG{o}{.}\PYG{n}{send\PYGZus{}action}\PYG{p}{(}\PYG{n}{action}\PYG{p}{)}

    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Episode finished! Starting new episode...}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{MintedVerbatim}
